#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <string.h>
#include "mem.h"

typedef union __header {
	struct {
		union __header *next;
		unsigned size;
	} node;
	long x;
} header;

int m_error = 0;
header *head = NULL;

int
main(int argc, char *argv[])
{

	/*// psudeo-random seed
	unsigned int seed = 0;

	// number of operations to perform
	long long n = 1000;

	// if true, write data into allocated memory
	int writeData = 1;

	// maximum number of concurrent allocations to track
	int max_allocs = 1000;

	// size for allocation request
	int min_alloc_size = 1;
	int max_alloc_size = 128;

	// allowed constant overhead
	int slack = 32;

	// max header size per allocation
	int header_size = 32;

	// request size up to 64+32, header up to 32 bytes
	int max_chunk_size = max_alloc_size + header_size;

	// most possible space, no more than max_allocs+1 unusable free chunks
	int region_size = max_allocs * max_chunk_size * 2 + max_chunk_size;

	void** ptr = calloc(sizeof(void*), max_allocs);
	int* size = calloc(sizeof(int), max_allocs);
	void** shadow = calloc(sizeof(void*), max_allocs);*/

	/*******************************************************************
	Please note that random() gives psudeo-random, not true random data.
	If the seed is set to the same value, the sequence generated by
	random() will be the same. Using psuedo-random number generators is
	a common testing technique.
	*******************************************************************/
	/*srandom(seed);

	printf("Mem_Init(%d) %s\n", region_size + slack, Mem_Init(region_size + slack) == 0?"true":"false");

	int slot;
	int doAlloc;
	int doWrite;

	long long i;


	for (i=0; i<n; i++) {
		slot = random() % max_allocs;
		doAlloc = random() % 4;
		doWrite = writeData;

		if (doAlloc == 0 || ptr[slot] != NULL) {
			//Mem_Dump();
			printf("Mem_Free(%p, 1) %s\n", ptr[slot], Mem_Free(ptr[slot], 1) == 0?"true":"false");
			free(shadow[slot]);
			ptr[slot] = NULL;
			shadow[slot] = NULL;
		}

		if (doAlloc != 0) {
			size[slot] = min_alloc_size +
			(random() % (max_alloc_size - min_alloc_size + 1));
			//Mem_Dump();
			ptr[slot] = Mem_Alloc(size[slot]);
			printf("%p = Mem_Alloc(%d) %lu %s\n", ptr[slot], size[slot], (size[slot]+15+sizeof(header))/16, ptr[slot] != NULL?"true":"false");
			if (doWrite != 0) {
				shadow[slot] = malloc(size[slot]);
				int j;
				for (j=0; j<size[slot]; j++) {
				   char data = random();
				   *((char*)(ptr[slot] + j)) = data;
				   *((char*)(shadow[slot] + j)) = data;
				}
			}
		}
	}

	if (writeData) {
		for (slot=0; slot<max_allocs; slot++) {
			if (ptr[slot] != NULL) {
				printf("memcmp(%p, %p, %d) %s\n", ptr[slot], shadow[slot], size[slot], memcmp(ptr[slot], shadow[slot], size[slot]) == 0?"true":"false");
			}
		}
	}*/


/*	printf("%s\n", Mem_Init(8000) == 0?"true":"false");
   	void* ptr = Mem_Alloc(8);
	printf("%s\n", ptr != NULL?"true":"false");*/

/*	void * ptr[5];

	ptr[0] = Mem_Alloc(640);
	printf("%s\n", ptr[0] != NULL?"true":"false");

	ptr[1] = Mem_Alloc(640);
	printf("%s\n", ptr[1] != NULL?"true":"false");

	ptr[2] = Mem_Alloc(640);
	printf("%s\n", ptr[2] != NULL?"true":"false");

	ptr[3] = Mem_Alloc(640);
	printf("%s\n", ptr[3] != NULL?"true":"false");

	ptr[4] = Mem_Alloc(640);
	printf("%s\n", ptr[4] != NULL?"true":"false");

	while (Mem_Alloc(640) != NULL)
	  ;

	printf("%s\n", m_error == E_NO_SPACE?"true":"false");

	printf("%s\n", Mem_Free(ptr[1], 0) == 0?"true":"false");
	printf("%s\n", Mem_Free(ptr[0], 0) == 0?"true":"false");
	printf("%s\n", Mem_Free(ptr[4], 0) == 0?"true":"false");
	printf("%s\n", Mem_Free(ptr[3], 0) == 0?"true":"false");

	printf("%s\n", Mem_Alloc(1280) == NULL?"true":"false");

	//Mem_Dump();

	printf("%s\n", Mem_Free(ptr[2], 1) == 0?"true":"false");

	//Mem_Dump();

	ptr[2] = Mem_Alloc(3200);
	printf("%s\n", ptr[2] != NULL?"true":"false");*/

	return 0;
}

int Mem_Init(int sizeOfRegion) {

	if(sizeOfRegion <= 0 || head != NULL) {
		m_error = E_BAD_ARGS;
		return -1;
	}

	if(sizeOfRegion % getpagesize() != 0) {
		sizeOfRegion += getpagesize() - (sizeOfRegion % getpagesize());
	}

	// open the /dev/zero device
	int fd = open("/dev/zero", O_RDWR);

	//printf("\n");

	// sizeOfRegion (in bytes) needs to be evenly divisible by the page size
	void *ptr = mmap(NULL, sizeOfRegion, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, fd, 0);
	if (ptr == MAP_FAILED) { 
		m_error = E_BAD_ARGS;
		perror("mmap"); 
		return -1;
	}

	/*int i;
	for(i = 0; i < (sizeOfRegion+7+sizeof(header))/8; i++) {
		printf("%d %d\n", i, *(int *)(ptr + i));
	}*/
	
	//printf("%p\n", ptr);

	// close the device (don't worry, mapping should be unaffected)
	close(fd);

	header *initHead = (header*)ptr;
	initHead->node.next = initHead;
	initHead->node.size = (sizeOfRegion-sizeof(header))/16;
	head = initHead;

	return 0;
}

void *Mem_Alloc(int size) {
	//printf("MemAlloc(%d)\n", size);
	unsigned units = (size+15+sizeof(header))/16;
	header *bestCurrNode = NULL, *bestPrevNode = NULL;
	header *currNode = head;
	header *prevNode = head;
	do {
		if(currNode->node.size == units) {
			bestCurrNode = currNode;
			bestPrevNode = prevNode;
			break;
		}
		if(currNode->node.size > units && (bestCurrNode == NULL || currNode->node.size < bestCurrNode->node.size)) {
			bestCurrNode = currNode;
			bestPrevNode = prevNode;
		}
		prevNode = currNode;
		currNode = currNode->node.next;
	} while (currNode != head);

	if(bestCurrNode != NULL) {
		if(bestCurrNode->node.size == units) {
			//Mem_Dump();
			if(bestPrevNode->node.next == bestCurrNode && bestCurrNode == head) {
				m_error = E_NO_SPACE;
				return NULL;
			}
			else if(bestCurrNode == head && bestPrevNode == bestCurrNode) {
				currNode = head ;
				do {
					prevNode = currNode;
					currNode = currNode->node.next;
				} while (currNode != head);
				head = bestCurrNode->node.next;
				prevNode->node.next = head;
			}
			else {
				bestPrevNode->node.next = bestCurrNode->node.next;
				head = bestPrevNode;	
			}
			//Mem_Dump();

			return (void *)(bestCurrNode+(sizeof(header)/16));
		}
		else {
			bestCurrNode->node.size -= units;
			bestCurrNode += bestCurrNode->node.size;
			bestCurrNode->node.size = units;
			head = bestPrevNode;
			return (void *)(bestCurrNode+(sizeof(header)/16));
		}
	}
	else {
		m_error = E_NO_SPACE;
		return NULL;
	}
}

int Mem_Free(void *ptr, int coalesce) {
	if(ptr == NULL) {
		return 0;
	} 
	//printf("MemFree(%p, %d)\n", ptr, coalesce);
	//printf("%p %u %u\n", ptr, *(unsigned *)ptr, *(unsigned *)(ptr - 1));
	header *block = ((header*)ptr-(sizeof(header)/16));
	//printf("Size %u\n", block->node.size);
	header *node = head;
	while(block < node || block > node->node.next) {
		if(node >= node->node.next && (block > node || block < node->node.next)) {
			break;
		}
		node = node->node.next;
	}
	//printf("NodeNext Block %p %p\n", node->node.next, block);

	if(block == node->node.next) {
		block = node->node.next->node.next;	
	}
	else {
		block->node.next = node->node.next;
		node->node.next = block;
	}
	

	if(node->node.next == node) {
		node->node.next = head;
	}
	if(block->node.next == block) {
		//printf("Block %d %p %ld\n", block->node.size, block, node - block);
		block->node.next = head;
	}
	head = node;

	if(coalesce != 0) {
		//printf("\n");
		//Mem_Dump();
		do {
			if(node->node.size+node == node->node.next) {
				node->node.size += node->node.next->node.size;
				node->node.next = node->node.next->node.next;
				head=node;
				//printf("\nCOALESCE\n");
				//Mem_Dump();
			}
			//printf("%d\n", node->node.size);
			node = node->node.next;
		} while (node != head);
		if(node->node.size+node == node->node.next) {
			node->node.size += node->node.next->node.size;
			node->node.next = node->node.next->node.next;
			head=node;
			//printf("\nCOALESCE\n");
			//Mem_Dump();
		}
	}
	return 0;
}

void Mem_Dump() {
	header *node = head, *prev = head;
	do {
		printf("%d %p %ld\n", node->node.size, node, node - prev);
		prev = node;
		node = node->node.next;
	} while (node != head);
}
